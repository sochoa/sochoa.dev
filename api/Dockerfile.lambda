# Build stage
FROM golang:1.25-alpine AS builder

WORKDIR /build

# Install build dependencies (including gcc for CGO/SQLite)
# Cached layer: only invalidates if apk packages change
RUN apk add --no-cache git ca-certificates tzdata gcc musl-dev sqlite-dev

# Copy go mod files (separate layer for better caching)
# Cached layer: only invalidates if go.mod/go.sum change
COPY go.mod go.sum ./

# Download dependencies (cached layer)
# This layer stays cached if source code changes but go.mod doesn't
RUN go mod download

# Copy source code (invalidates cache if any source changes)
COPY . .

# Build the binary for Lambda with optimizations
# Flags:
#   -s -w: strip symbols & debug info (10-20% smaller binary)
#   -trimpath: remove absolute paths (reproducible builds, better caching)
# The binary must be named 'bootstrap' for Lambda custom runtime
RUN CGO_ENABLED=1 GOOS=linux GOARCH=arm64 \
    go build \
      -trimpath \
      -ldflags="-s -w" \
      -o bootstrap \
      .

# Lambda runtime stage
FROM public.ecr.aws/lambda/provided:al2.2024.12.11-arm64

# Copy ca-certificates and timezone data from builder
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo

# Copy bootstrap binary (Lambda expects this name as the entry point)
COPY --from=builder /build/bootstrap ${LAMBDA_TASK_ROOT}

# Lambda runtime will invoke the bootstrap binary with AWS_LAMBDA_FUNCTION_NAME set
# Our code detects this env var and starts the Lambda handler instead of the HTTP server
CMD [ "bootstrap" ]
